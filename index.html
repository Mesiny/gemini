<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 手势交互粒子系统</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        /* UI 容器 */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        /* 摄像头预览 (为了调试，设为镜像并缩小，也可隐藏) */
        #video-preview {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transform: scaleX(-1);
            /* 镜像 */
            z-index: 5;
            opacity: 0.7;
        }

        /* 全屏按钮 */
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: 0.3s;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* 加载提示 */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            pointer-events: none;
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
          "lil-gui": "https://unpkg.com/lil-gui@0.18.0/dist/lil-gui.esm.min.js"
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

    <button id="fullscreen-btn">⛶ 全屏模式</button>
    <video id="video-preview" playsinline></video>
    <div id="loader">正在启动摄像头与模型...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // --- 全局变量 ---
        let scene, camera, renderer, particles, geometry, material;
        let originalPositions = []; // 存储目标形状的坐标
        let currentShape = 'heart'; // 当前形状
        const particleCount = 12000; // 粒子数量
        let handOpenFactor = 0; // 手势控制因子 (0 = 闭合/原始状态, 1 = 张开/扩散)
        const videoElement = document.getElementById('video-preview');

        // --- 初始化 Three.js ---
        function init() {
            scene = new THREE.Scene();
            // 增加一点环境雾气
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 2.0;

            // 创建粒子系统
            createParticles();

            // UI 面板
            setupGUI();

            // 事件监听
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);

            // 动画循环
            animate();
        }

        // --- 粒子系统逻辑 ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            // 初始化位置（随机分布）
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // 粒子材质
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            material = new THREE.PointsMaterial({
                size: 0.3,
                map: sprite,
                vertexColors: false, // 我们暂时使用统一颜色，或者在 shader 中处理
                color: new THREE.Color(0xff0055),
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 生成初始目标形状
            updateTargetShape('heart');
        }

        // --- 形状生成算法 ---
        function getShapePoints(type) {
            const points = [];
            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                if (type === 'heart') {
                    // 爱心方程 (LaTeX: 16sin^3(t), 13cos(t)-5cos(2t)-2cos(3t)-cos(4t))
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.random();

                    // 核心爱心形状
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    z = (Math.random() - 0.5) * 4; // 厚度

                    // 20%的粒子分布在内部，密度随半径减小
                    if (Math.random() < 0.05) {
                        const innerFactor = Math.pow(r, 2); // 平方使中心密度更低
                        x *= innerFactor * 0.8;
                        y *= innerFactor * 0.8;
                    } else {
                        // 轮廓粒子稍微打散
                        x *= 0.5 + r * 0.2;
                        y *= 0.5 + r * 0.2;
                    }
                }
                else if (type === 'saturn') {
                    // 土星: 球体 + 环
                    const isRing = Math.random() > 0.6; // 40% 球体, 60% 环
                    if (!isRing) {
                        const r = 4;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else {
                        const r = 7 + Math.random() * 4; // 环半径 7-11
                        const theta = Math.random() * Math.PI * 2;
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta);
                        y = (Math.random() - 0.5) * 0.5; // 环很薄
                        // 倾斜环
                        const tilt = Math.PI / 6;
                        const tempY = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const tempZ = y * Math.sin(tilt) + z * Math.cos(tilt);
                        y = tempY; z = tempZ;
                    }
                }
                else if (type === 'fireworks') {
                    // 烟花: 球形随机扩散
                    const r = 10 * Math.cbrt(Math.random()); // 均匀球体分布
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                else if (type === 'clover') {
                    // 三叶草形状
                    const t = Math.random() * Math.PI * 2;
                    const u = Math.random();

                    // 三叶草参数方程
                    const r = 6 * (1 + 0.8 * Math.sin(3 * t)); // 三叶形状
                    const heightVariance = 2 * (u - 0.5); // 高度变化

                    x = r * Math.cos(t);
                    y = r * Math.sin(t);
                    z = heightVariance;

                    // 添加一些随机性使分布更自然
                    x += (Math.random() - 0.5) * 1.5;
                    y += (Math.random() - 0.5) * 1.5;
                    z += (Math.random() - 0.5) * 0.8;
                }

                points.push({ x, y, z });
            }
            return points;
        }

        function updateTargetShape(type) {
            currentShape = type;
            originalPositions = getShapePoints(type);
        }

        // --- 实时更新逻辑 ---
        let randomPositions = []; // 固定随机位置数组

        function animate() {
            requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position.array;

            // 只在第一次或形状变化时初始化随机位置
            if (randomPositions.length !== particleCount) {
                randomPositions = new Array(particleCount).fill(0).map(() => ({
                    x: (Math.random() - 0.5) * 100,
                    y: (Math.random() - 0.5) * 100,
                    z: (Math.random() - 0.5) * 100
                }));
            }

            const time = Date.now() * 0.001; // 获取时间用于飘动动画

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 根据手势因子混合目标位置
                const targetX = originalPositions[i].x * (1 - handOpenFactor) + randomPositions[i].x * handOpenFactor;
                const targetY = originalPositions[i].y * (1 - handOpenFactor) + randomPositions[i].y * handOpenFactor;
                const targetZ = originalPositions[i].z * (1 - handOpenFactor) + randomPositions[i].z * handOpenFactor;

                // 添加缓慢飘动效果 (仅当手接近闭合时)
                const driftAmount = (1 - handOpenFactor) * 0.1; // 飘动强度
                const driftX = Math.sin(time * 0.3 + i * 0.01) * driftAmount;
                const driftY = Math.cos(time * 0.2 + i * 0.02) * driftAmount;
                const driftZ = Math.sin(time * 0.25 + i * 0.015) * driftAmount;

                // 平滑过渡到目标位置 + 飘动效果
                positions[ix] += (targetX + driftX - positions[ix]) * 0.05;
                positions[iy] += (targetY + driftY - positions[iy]) * 0.05;
                positions[iz] += (targetZ + driftZ - positions[iz]) * 0.05;
            }

            particles.geometry.attributes.position.needsUpdate = true;

            // 整体缓慢旋转效果
            const rotationSpeed = 0.001; // 控制旋转速度
            particles.rotation.y += rotationSpeed;
            // particles.rotation.x += rotationSpeed * 0.5; // X轴旋转速度减半

            renderer.render(scene, camera);
        }

        // --- UI 设置 ---
        function setupGUI() {
            const gui = new GUI({ title: '控制面板' });

            const params = {
                shape: 'heart',
                color: '#ff0055',
                particleSize: 0.5,
                simulateHand: 0 // 用于无摄像头时的调试
            };

            // 模型选择
            gui.add(params, 'shape', ['heart', 'saturn', 'fireworks', 'clover']).name('模型形状').onChange(val => {
                updateTargetShape(val);
                // 根据形状自动切颜色
                if (val === 'saturn') params.color = '#ffcc00';
                if (val === 'fireworks') params.color = '#00ffff';
                if (val === 'clover') params.color = '#00ff88'; // 三叶草的默认颜色
                material.color.set(params.color);
            });

            // 颜色选择
            gui.addColor(params, 'color').name('粒子颜色').onChange(val => {
                material.color.set(val);
            });

            // 粒子大小
            gui.add(params, 'particleSize', 0.1, 2.0).name('粒子大小').onChange(val => {
                material.size = val;
            });

            // 调试用：模拟手势
            gui.add(params, 'simulateHand', 0, 1).name('模拟手势(调试)').onChange(val => {
                handOpenFactor = val;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // --- MediaPipe 手势识别集成 ---
        function setupMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            cameraUtils.start()
                .then(() => document.getElementById('loader').style.display = 'none')
                .catch(err => {
                    console.error(err);
                    document.getElementById('loader').innerText = "无法启动摄像头，请使用右侧面板调试滑块。";
                });
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 计算大拇指指尖(4)和食指指尖(8)的距离
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 距离映射：一般捏合是 <0.05，张开 >0.2
                // 我们将 0.05 - 0.25 映射到 0 - 1
                let factor = (distance - 0.05) * 5;
                factor = Math.max(0, Math.min(1, factor)); // 钳制在 0 到 1 之间

                // 平滑插值，避免手抖动导致粒子闪烁
                handOpenFactor = THREE.MathUtils.lerp(handOpenFactor, factor, 0.1);
            } else {
                // 如果没检测到手，慢慢恢复原状
                handOpenFactor = THREE.MathUtils.lerp(handOpenFactor, 0, 0.05);
            }
        }

        // 启动程序
        init();
        setupMediaPipe();

    </script>
</body>

</html>